import os
import uuid
from typing import Any, List, Iterable
from dotenv import load_dotenv

# Required packages:
# pip install -U langchain-azure-ai mem0 langchain-openai azure-cosmos azure-identity

from langchain_azure_ai.vectorstores import AzureCosmosDBNoSqlVectorSearch
from mem0 import Memory
from langchain_openai import AzureChatOpenAI, AzureOpenAIEmbeddings
from azure.cosmos import CosmosClient
from azure.identity import DefaultAzureCredential
from langchain_core.documents import Document

# --- Load Environment Variables ---
load_dotenv()

# --- Azure & Cosmos DB Configuration ---
azure_openai_api_key = os.getenv("AZURE_OPENAI_API_KEY")
azure_openai_endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")
azure_openai_api_version = os.getenv("AZURE_OPENAI_API_VERSION")
azure_openai_deployment_name = os.getenv("AZURE_OPENAI_DEPLOYMENT_NAME")
azure_openai_embedding_deployment_name = os.getenv("AZURE_OPENAI_EMBEDDING_DEPLOYMENT_NAME")
cosmosdb_endpoint = os.getenv("AZURE_COSMOSDB_ENDPOINT")
cosmosdb_database_name = os.getenv("AZURE_COSMOSDB_DATABASE_NAME")
cosmosdb_container_name = "mem0"

# --- Wrapper Class for Compatibility with Mem0 ---

class CosmosDBMem0Wrapper(AzureCosmosDBNoSqlVectorSearch):
    """
    A wrapper for AzureCosmosDBNoSqlVectorSearch to make it fully
    compatible with mem0. Ensures proper formatting and metadata.
    """

    def add_texts(
        self,
        texts: Iterable[str],
        metadatas: List[dict] | None = None,
        **kwargs: Any,
    ) -> List[str]:
        """Ensure each document has 'id' and 'data' fields."""
        if not metadatas:
            metadatas = [{} for _ in texts]

        formatted_metadatas = []
        for idx, metadata in enumerate(metadatas):
            formatted = metadata.copy()
            if 'id' not in formatted or not formatted['id']:
                formatted['id'] = str(uuid.uuid4())
            formatted['data'] = texts[idx]
            formatted_metadatas.append(formatted)

        return super().add_texts(texts, formatted_metadatas, **kwargs)

    def similarity_search_by_vector(
        self, embedding: List[float], k: int = 4, **kwargs: Any
    ) -> List[Document]:
        """Ensure returned documents have 'id' and 'data'."""
        try:
            docs = self.similarity_search(
                query="",
                k=k,
                search_type="similarity",
                vector=embedding,
                **kwargs
            )

            formatted_docs = []
            for doc in docs:
                metadata = doc.metadata.copy() if doc.metadata else {}

                # ✅ Ensure valid 'id' field
                if not metadata.get("id"):
                    metadata["id"] = str(uuid.uuid4())

                # ✅ Ensure 'data' field required by mem0
                metadata["data"] = doc.page_content

                formatted_doc = Document(
                    page_content=doc.page_content,
                    metadata=metadata
                )
                formatted_docs.append(formatted_doc)

            return formatted_docs
        except Exception as e:
            print(f"Error in similarity_search_by_vector: {e}")
            return []

# --- Initialize Clients ---
print("Initializing clients...")

embedder = AzureOpenAIEmbeddings(
    azure_deployment=azure_openai_embedding_deployment_name,
    openai_api_version=azure_openai_api_version,
    azure_endpoint=azure_openai_endpoint,
    api_key=azure_openai_api_key
)

llm = AzureChatOpenAI(
    azure_deployment=azure_openai_deployment_name,
    api_version=azure_openai_api_version,
    azure_endpoint=azure_openai_endpoint,
    api_key=azure_openai_api_key,
)

credential = DefaultAzureCredential()
cosmos_client = CosmosClient(url=cosmosdb_endpoint, credential=credential)

EMBEDDING_DIMENSIONS = 1536

vector_embedding_policy = {
    "vectorEmbeddings": [
        {
            "path": "/vectorContent",
            "dataType": "float32",
            "dimensions": EMBEDDING_DIMENSIONS,
            "distanceFunction": "cosine",
        },
    ]
}
indexing_policy = {
    "includedPaths": [
        {"path": "/*"},
        {"path": "/metadata/*"},
        {"path": "/id/?"},
        {"path": "/data/?"}
    ],
    "excludedPaths": [{"path": '/"_etag"/?'}],
    "vectorIndexes": [
        {"path": "/vectorContent", "type": "quantizedFlat"},
    ],
}

# --- Initialize Vector Store ---
print("Initializing Azure Cosmos DB for NoSQL Vector Store...")

vector_store = CosmosDBMem0Wrapper(
    cosmos_client=cosmos_client,
    database_name=cosmosdb_database_name,
    container_name=cosmosdb_container_name,
    embedding=embedder,
    vector_embedding_policy=vector_embedding_policy,
    indexing_policy=indexing_policy,
    cosmos_container_properties={"partition_key": {"paths": ["/id"], "kind": "Hash"}},
    cosmos_database_properties={},
    vector_search_fields={
        "text_field": "text",
        "embedding_field": "vectorContent",
        "metadata_field": "metadata",
    }
)

print("Vector store initialized successfully.")

# --- Mem0 Configuration ---
config = {
    "vector_store": {
        "provider": "langchain",
        "config": {"client": vector_store},
    },
    "llm": {
        "provider": "langchain",
        "config": {"model": llm},
    },
    "embedder": {
        "provider": "langchain",
        "config": {"model": embedder},
    },
}

# --- Run Mem0 Memory ---
print("\nInitializing Mem0 from config...")
m = Memory.from_config(config)
print("Mem0 initialized.")

messages = [
    {"role": "user", "content": "My favorite movies are 'The Matrix' and 'Inception'."},
    {"role": "assistant", "content": "Great choices!"},
    {"role": "user", "content": "I also love 'Blade Runner 2049'."},
    {"role": "assistant", "content": "A modern classic!"},
]

print("\nAdding memories...")
result = m.add(messages, user_id="alice", metadata={"category": "movies"})
print("Added memories:", result)

print("\nSearching for memories...")
search_results = m.search("What movies does the user like?", user_id="alice")
print("Search results:", search_results)
